#!/usr/bin/env -S fontforge -quiet
# -*- mode: python; coding: utf-8 -*-

import os
import fontforge
import re
import argparse
import psMat
import statistics

def main():
    global args
    parser = argparse.ArgumentParser(description="import SVG characters")
    parser.add_argument('font_filename', help="font filename")
    parser.add_argument('svg_filenames', nargs='+', help="svg characters")
    parser.add_argument('--expand-stroke', '-x', type=int, help="number of pixels to expand stroke")
    parser.add_argument('--dry-run', '-n', action='store_true')
    parser.add_argument('-o', '--save-as', '--output', type=str, help="after editing, save as new file, converts if file extension is different")
    parser.add_argument('--translate-x', type=int)
    parser.add_argument('--translate-y', type=int)
    parser.add_argument('--scale-y', type=float)
    parser.add_argument('--scale-y-from', type=float)
    parser.add_argument('--scale-x', type=float)
    parser.add_argument('--scale-x-from', type=float)
    args = parser.parse_args()

    print("Loading %s" % args.font_filename)
    font = fontforge.open(args.font_filename)
    write_font_filename = args.save_as if args.save_as is not None else args.font_filename

    svg_char_structs = []
    smol_char_structs = []

    for svg_filename in args.svg_filenames:
        (codepoint, glyphname, suffix) = parse_glyph_svg_filename(svg_filename)
        plain_glyphname = glyphname.split('.')[0]
        real_codepoint = fontforge.unicodeFromName(plain_glyphname)
        if codepoint is None and glyphname is None:
            print("%s: not an SVG character filename; skipping" % svg_filename)
            continue

        svg_char_structs.append([
            codepoint,
            glyphname,
            suffix,
            plain_glyphname,
            real_codepoint,
            svg_filename,
        ])

        # create autogenerated .smol glyphs for **original** ASCII printables
        if codepoint in range(33,127) or suffix == 'orig':
            sm_glyphname = plain_glyphname + '.smol'
            smol_char_structs.append([
                codepoint,
                sm_glyphname,
                '.smol',
                plain_glyphname,
                real_codepoint,
                svg_filename,
            ])

    for struct in svg_char_structs:
        (codepoint, glyphname, suffix, plain_glyphname, real_codepoint, svg_filename) = struct
        glyph = font.createChar(codepoint, glyphname)
        struct.append(glyph)

    for struct in svg_char_structs:
        (codepoint, glyphname, suffix, plain_glyphname, real_codepoint, svg_filename, glyph) = struct
        do_import_work(font, glyph, svg_filename)
        do_outline_work(font, glyph, args.expand_stroke)

    for struct in smol_char_structs:
        (codepoint, sm_glyphname, suffix, plain_glyphname, real_codepoint, svg_filename) = struct
        sm_glyph = font.createChar(-1, sm_glyphname)
        struct.append(sm_glyph)

    for struct in smol_char_structs:
        (codepoint, sm_glyphname, suffix, plain_glyphname, real_codepoint, svg_filename, sm_glyph) = struct
        do_import_work(font, sm_glyph, svg_filename)
        sm_glyph.transform(psMat.scale(0.5))
        sm_glyph.transform(psMat.translate(glyph.width / 4, args.expand_stroke / 4))
        sm_glyph.width = glyph.width
        do_outline_work(font, sm_glyph, args.expand_stroke)

    if (args.translate_x or args.translate_y or args.scale_x or args.scale_y):
        for glyph in font.glyphs():
            if glyph.unicode in range(0x2800, 0x2900) or glyph.unicode in range(0x2500, 0x25a0):
                # Leave Braille, Box Drawing, and Block Elements alone.
                continue
            # Unfortunately some upside down references would have
            # the wrong offset if we simply transformed them.
            if len(glyph.references) and not len(glyph.foreground):
                # Ordinarily a glyph.unlinkRef() call would replace
                # the refs with the contours from when the font was
                # loaded, ignoring any changes such as the .stroke()
                # calls.
                reconstitute_references(glyph)
                glyph.unlinkRef()
        for glyph in font.glyphs():
            if glyph.unicode in range(0x2800, 0x2900) or glyph.unicode in range(0x2500, 0x25a0):
                # Leave Braille, Box Drawing, and Block Elements alone.
                continue
            xform = psMat.identity()
            orig_width = glyph.width
            if args.scale_y:
                scale_y = args.scale_y / args.scale_y_from if args.scale_y_from else args.scale_y
                xform = psMat.compose(xform, psMat.scale(1.0, scale_y))
            if args.scale_x:
                scale_x = args.scale_x / args.scale_x_from if args.scale_x_from else args.scale_x
                xform = psMat.compose(xform, psMat.translate(-orig_width / 2, 0))
                xform = psMat.compose(xform, psMat.scale(scale_x, 1.0))
                xform = psMat.compose(xform, psMat.translate(orig_width / 2, 0))
            if args.translate_y or args.translate_x:
                xlate_x = args.translate_x if args.translate_x else 0
                xlate_y = args.translate_y if args.translate_y else 0
                xform = psMat.compose(xform, psMat.translate(xlate_x, xlate_y))
            glyph.transform(xform)
            glyph.left_side_bearing = int(glyph.left_side_bearing + round((orig_width - glyph.width) / 2))
            glyph.width = orig_width
            glyph.removeOverlap()

    if args.dry_run:
        print("DRY RUN: not saving or generating %s" % write_font_filename)
        return
    if os.path.splitext(write_font_filename)[1] == '.sfd':
        print("Saving %s" % write_font_filename)
        font.save(write_font_filename)
    else:
        print("Generating %s" % write_font_filename)
        font.generate(write_font_filename)

def font_glyph_width(font):
    return statistics.median([glyph.width for glyph in font.glyphs()])

def do_import_work(font, glyph, svg_filename):
    global args
    glyph.foreground = fontforge.layer()

    # Import just the paths without expanding strokes.
    font.strokedfont = True
    glyph.importOutlines(svg_filename)
    font.strokedfont = False

def do_outline_work(font, glyph, expand_stroke=None):
    global args
    orig_width = glyph.width
    if expand_stroke is not None:
        glyph.stroke("circular", expand_stroke, "round", "round")
    glyph.removeOverlap()
    glyph.width = orig_width

def parse_glyph_svg_filename(svg_filename):
    (svg_dirname, svg_basename) = os.path.split(svg_filename)
    match_1 = re.search(r'^(?:u\+|0x)?([0-9a-f]+)', svg_basename, flags=re.IGNORECASE)
    match_2 = re.search(r'^x--', svg_basename, flags=re.IGNORECASE)
    match_3 = re.search(r'--(.+)$', os.path.splitext(svg_basename)[0]) # foo--bar.svg => "bar"
    if not match_1 and not match_2:
        return [None, None]
    suffix = match_3.expand('\\1') if match_3 else None
    hex = match_1.expand('\\1') if match_1 else None
    codepoint = int(hex, 16) if hex is not None else -1
    if codepoint < 0:
        glyphname = suffix
    elif suffix is not None:
        glyphname = fontforge.nameFromUnicode(codepoint) + "." + suffix
        codepoint = -1
    else:
        glyphname = fontforge.nameFromUnicode(codepoint)
    return [codepoint, glyphname, suffix]

def reconstitute_references(glyph):
    # Apparently a glyph.unlinkRef() call will replace the
    # references with the contours from when the font was
    # loaded, ignoring any changes we make to the glyph.
    references = glyph.references
    glyph.references = []
    for reference in references:
        glyph.addReference(reference[0], reference[1])

main()
