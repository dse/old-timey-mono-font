#!/usr/bin/env -S fontforge -quiet
# -*- mode: python; coding: utf-8 -*-

import os
import fontforge
import re
import argparse
import psMat

def main():
    global args
    parser = argparse.ArgumentParser(description="import SVG characters")
    parser.add_argument('font_filename', help="font filename")
    parser.add_argument('svg_filenames', nargs='+', help="svg characters")
    parser.add_argument('--expand-stroke', '-x', type=int, help="number of pixels to expand stroke")
    parser.add_argument('--expand-sm-stroke', '-X', type=int, help="number of pixels to expand stroke in .smol glyphs")
    parser.add_argument('--glyph-width', '--width', '-w', type=int, help="glyph width", default=1008)
    parser.add_argument('--dry-run', '-n', action='store_true')
    parser.add_argument('--ignore-svg-stroke-width', action='store_true',
                        help='ignore SVG stroke widths')
    args = parser.parse_args()

    print("Loading %s" % args.font_filename)
    font = fontforge.open(args.font_filename)

    expand_sm_stroke = args.expand_sm_stroke if args.expand_sm_stroke is not None else args.expand_stroke

    for svg_filename in args.svg_filenames:
        (codepoint, glyphname) = parse_glyph_svg_filename(svg_filename)
        if codepoint is None and glyphname is None:
            print("%s: not an SVG character filename; skipping" % svg_filename)
            continue
        glyph = font.createChar(codepoint, glyphname)
        do_import_work(font, glyph, svg_filename)
        do_outline_work(font, glyph, args.expand_stroke)
        if codepoint in range(33,127):
            # create autogenerated .smol glyphs for ASCII printables
            sm_glyphname = fontforge.nameFromUnicode(codepoint) + '.smol'
            sm_glyph = font.createChar(-1, sm_glyphname)
            do_import_work(font, sm_glyph, svg_filename)
            sm_glyph.transform(psMat.scale(0.5))
            sm_glyph.transform(psMat.translate(glyph.width / 4, expand_sm_stroke / 4))
            sm_glyph.width = glyph.width
            do_outline_work(font, sm_glyph, expand_sm_stroke)

    if args.dry_run:
        print("DRY RUN: not saving or generating %s" % args.font_filename)
        return
    if os.path.splitext(args.font_filename)[1] == '.sfd':
        print("Saving %s" % args.font_filename)
        font.save(args.font_filename)
    else:
        print("Generating %s" % args.font_filename)
        font.generate(args.font_filename)

def do_import_work(font, glyph, svg_filename):
    global args
    glyph.foreground = fontforge.layer()
    if args.ignore_svg_stroke_width:
        # Import just the paths without expanding strokes.
        font.strokedfont = True
        glyph.importOutlines(svg_filename)
        font.strokedfont = False
    else:
        # Fontforge will expand the strokes to their svg stroke
        # widths.
        glyph.importOutlines(svg_filename)

def do_outline_work(font, glyph, expand_stroke=None):
    global args
    codepoint = glyph.codepoint
    if expand_stroke is not None:
        glyph.stroke("circular", expand_stroke, "round", "round")
    glyph.removeOverlap()
    glyph.width = args.glyph_width

def parse_glyph_svg_filename(svg_filename):
    (svg_dirname, svg_basename) = os.path.split(svg_filename)
    match_1 = re.search(r'^(?:u\+|0x)?([0-9a-f]+)', svg_basename, flags=re.IGNORECASE)
    match_2 = re.search(r'^x--', svg_basename, flags=re.IGNORECASE)
    match_3 = re.search(r'--(.+)$', os.path.splitext(svg_basename)[0]) # foo--bar.svg => "bar"
    if not match_1 and not match_2:
        return [None, None]
    suffix = match_3.expand('\\1') if match_3 else None
    hex = match_1.expand('\\1') if match_1 else None
    codepoint = int(hex, 16) if hex is not None else -1
    if codepoint < 0:
        glyphname = suffix
    elif suffix is not None:
        glyphname = fontforge.nameFromUnicode(codepoint) + "." + suffix
        codepoint = -1
    else:
        glyphname = fontforge.nameFromUnicode(codepoint)
    return [codepoint, glyphname]

main()
